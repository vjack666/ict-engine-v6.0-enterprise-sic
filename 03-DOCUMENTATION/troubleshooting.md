# üîß ICT Engine v6.0 Enterprise - Troubleshooting Guide

**üìÖ √öltima actualizaci√≥n:** Septiembre 9, 2025  
**üéØ Versi√≥n:** v6.0 Enterprise SIC  
**‚ö° Tiempo de resoluci√≥n:** 2-30 minutos seg√∫n severidad  

---

## üö® **CLASIFICACI√ìN DE PROBLEMAS**

### **‚ö° CR√çTICOS (Resolver INMEDIATAMENTE)**
- üö´ Sistema no arranca / imports fallan
- üíæ P√©rdida de datos o corrupci√≥n  
- ‚ö° Performance <50% del baseline
- üö® Risk violations activas (MAX_POSITIONS, EMERGENCY_STOP)
- üî¥ Tests core fallando >80%

### **üî∂ ALTOS (Resolver en <2 horas)**
- üîß Funcionalidad enterprise parcialmente no funcional
- üß† Memory leaks detectados
- üìä Performance 50-80% del baseline
- üîó Integration tests fallando
- üìù Logging/configuraci√≥n problem√°tica

### **üî∏ MEDIOS (Resolver en <1 d√≠a)**
- üõ†Ô∏è Features espec√≠ficos no funcionando
- üìà Performance 80-90% del baseline
- üß™ Unit tests fallando <20%
- üìö Documentaci√≥n inconsistente
- ‚ö†Ô∏è Warnings en producci√≥n

---

## ü©∫ **DIAGN√ìSTICO R√ÅPIDO (2 minutos)**

### **1Ô∏è‚É£ VALIDACI√ìN AUTOM√ÅTICA DEL SISTEMA**
```powershell
# Ejecutar diagn√≥stico completo
python 06-TOOLS\validation_quick_test.py

# ‚úÖ Resultado esperado: Score >= 80%
# ‚ùå Si Score < 60%: Problema cr√≠tico detectado
```

### **2Ô∏è‚É£ VERIFICACI√ìN DE ESTRUCTURA**
```powershell
# Verificar integridad del proyecto
Write-Host "üìÇ Verificando estructura del proyecto..." -ForegroundColor Green
$folders = @("01-CORE", "03-DOCUMENTATION", "04-DATA", "05-LOGS", "06-TOOLS", "09-DASHBOARD")
foreach ($folder in $folders) {
    if (Test-Path $folder) {
        Write-Host "  ‚úÖ $folder" -ForegroundColor Green
    } else {
        Write-Host "  ‚ùå $folder FALTANTE" -ForegroundColor Red
    }
}
```

### **3Ô∏è‚É£ VERIFICACI√ìN DE CONFIGURACIONES CR√çTICAS**
```powershell
# Verificar archivos de configuraci√≥n esenciales
Write-Host "‚öôÔ∏è Verificando configuraciones cr√≠ticas..." -ForegroundColor Green
$configs = @(
    "01-CORE\config\log_throttle_config.json",
    "01-CORE\config\risk_management_config.json", 
    "01-CORE\config\timestamp_config.json",
    "01-CORE\config\log_categorization_rules.json"
)
foreach ($config in $configs) {
    if (Test-Path $config) {
        Write-Host "  ‚úÖ $(Split-Path $config -Leaf)" -ForegroundColor Green
    } else {
        Write-Host "  ‚ùå $(Split-Path $config -Leaf) FALTANTE" -ForegroundColor Red
    }
}
```

---

## üö® **PROBLEMAS CR√çTICOS Y SOLUCIONES**

### **‚ùå PROBLEMA: Sistema no arranca**

**üîç S√≠ntomas:**
- Error al ejecutar `python main.py`
- ModuleNotFoundError
- Import errors masivos

**‚ö° SOLUCI√ìN INMEDIATA:**
```powershell
# 1. Verificar versi√≥n de Python
python --version
# Debe ser Python 3.8 o superior

# 2. Instalar dependencias
pip install -r requirements.txt

# 3. Verificar imports cr√≠ticos
python -c "
try:
    import pandas as pd
    import numpy as np
    print('‚úÖ Librer√≠as b√°sicas OK')
except Exception as e:
    print(f'‚ùå Error en librer√≠as: {e}')
"

# 4. Ejecutar auto-reparaci√≥n
python 06-TOOLS\system_auto_repair.py
```

### **‚ùå PROBLEMA: Risk Violations Activas**

**üîç S√≠ntomas:**
- ERROR: RISK_VIOLATION: MAX_POSITIONS
- CRITICAL: EMERGENCY_ACTION: EMERGENCY_STOP
- Sistema bloqueado para trading

**‚ö° SOLUCI√ìN INMEDIATA:**
```powershell
# 1. Verificar estado actual de risk management
python -c "
import json
with open('01-CORE/config/risk_management_config.json') as f:
    config = json.load(f)
    print(f'Max positions: {config[\"max_positions\"]}')
    print(f'Max drawdown: {config[\"max_drawdown_percent\"]}%')
    print(f'Emergency stop: {config[\"emergency_stop_enabled\"]}')
"

# 2. Resolver violaciones manualmente
python 01-CORE\risk_management\risk_validator.py --reset-emergency

# 3. Verificar resoluci√≥n
python 06-TOOLS\validation_quick_test.py
```

### **‚ùå PROBLEMA: Logs Duplicados Masivos**

**üîç S√≠ntomas:**
- Archivos de log >1000 l√≠neas
- Mensajes id√©nticos repetidos
- Performance degradada

**‚ö° SOLUCI√ìN INMEDIATA:**
```powershell
# 1. Ejecutar limpieza r√°pida
python 06-TOOLS\clean_test_logs.py

# 2. Verificar rate limiting
python -c "
import json
with open('01-CORE/config/log_throttle_config.json') as f:
    config = json.load(f)
    print(f'Max logs/seg: {config[\"max_logs_per_second\"]}')
    print(f'Rate limiting: {config.get(\"enabled\", False)}')
"

# 3. Reiniciar logger con throttling
python -c "
from core.smart_trading_logger import SmartTradingLogger
logger = SmartTradingLogger('test')
logger.info('Test despu√©s de throttling')
print('‚úÖ Logger funcionando con rate limiting')
"
```

### **‚ùå PROBLEMA: Timestamps Inconsistentes**

**üîç S√≠ntomas:**
- Formatos de tiempo mezclados en logs
- Dificultad para analizar cronolog√≠a
- Validation score bajo

**‚ö° SOLUCI√ìN INMEDIATA:**
```powershell
# 1. Verificar configuraci√≥n de timestamps
python -c "
import json
with open('01-CORE/config/timestamp_config.json') as f:
    config = json.load(f)
    print(f'Formato: {config[\"format\"]}')
    print(f'Timezone: {config[\"timezone\"]}')
    print(f'Estandarizado: {config[\"standardized\"]}')
"

# 2. Estandarizar timestamps existentes
python 01-CORE\utils\timestamp_standardizer.py --fix-existing

# 3. Verificar correcci√≥n
python 06-TOOLS\validation_quick_test.py
```

---

## üîß **HERRAMIENTAS DE DIAGN√ìSTICO AVANZADO**

### **ü©∫ Health Check Completo**
```powershell
# Crear script de health check
@"
import json
import psutil
import os
from datetime import datetime
from pathlib import Path

def system_health_check():
    results = {
        'timestamp': datetime.now().isoformat(),
        'status': 'unknown',
        'checks': {}
    }
    
    # Check 1: Memory usage
    memory = psutil.virtual_memory()
    results['checks']['memory'] = {
        'current': memory.used / 1024 / 1024,  # MB
        'total': memory.total / 1024 / 1024,   # MB
        'percent': memory.percent,
        'status': 'ok' if memory.percent < 80 else 'warning'
    }
    
    # Check 2: Disk space
    disk = psutil.disk_usage('.')
    results['checks']['disk'] = {
        'free': disk.free / 1024 / 1024,      # MB
        'total': disk.total / 1024 / 1024,    # MB
        'percent': (disk.used / disk.total) * 100,
        'status': 'ok' if disk.free > 1000 else 'warning'  # 1GB free
    }
    
    # Check 3: Critical files
    critical_files = [
        '01-CORE/config/log_throttle_config.json',
        '01-CORE/config/risk_management_config.json',
        '01-CORE/utils/realtime_log_deduplicator.py'
    ]
    
    missing_files = []
    for file_path in critical_files:
        if not Path(file_path).exists():
            missing_files.append(file_path)
    
    results['checks']['files'] = {
        'total_critical': len(critical_files),
        'missing': len(missing_files),
        'missing_files': missing_files,
        'status': 'ok' if len(missing_files) == 0 else 'error'
    }
    
    # Check 4: Import test
    try:
        import pandas as pd
        import numpy as np
        results['checks']['imports'] = {'status': 'ok'}
    except Exception as e:
        results['checks']['imports'] = {
            'status': 'error',
            'error': str(e)
        }
    
    # Overall status
    all_statuses = [check.get('status', 'unknown') for check in results['checks'].values()]
    if 'error' in all_statuses:
        results['status'] = 'critical'
    elif 'warning' in all_statuses:
        results['status'] = 'warning'
    else:
        results['status'] = 'healthy'
    
    return results

if __name__ == '__main__':
    health = system_health_check()
    print(json.dumps(health, indent=2))
    
    if health['status'] == 'critical':
        print('\nüö® CRITICAL ISSUES DETECTED')
        exit(1)
    elif health['status'] == 'warning':
        print('\n‚ö†Ô∏è WARNINGS DETECTED')
        exit(2)
    else:
        print('\n‚úÖ SYSTEM HEALTHY')
        exit(0)
"@ | Out-File -FilePath "06-TOOLS\health_check.py" -Encoding UTF8

# Ejecutar health check
python 06-TOOLS\health_check.py
```

### **üìä Performance Monitor**
```powershell
# Monitor de performance en tiempo real
python -c "
import time
import psutil
import threading
from datetime import datetime

class PerformanceMonitor:
    def __init__(self):
        self.monitoring = False
        
    def start_monitoring(self, duration=60):
        self.monitoring = True
        start_time = datetime.now()
        
        print(f'üîç Iniciando monitoreo de performance por {duration} segundos...')
        print('Timestamp,CPU%,Memory MB,Disk Read MB/s,Disk Write MB/s')
        
        prev_disk = psutil.disk_io_counters()
        
        for i in range(duration):
            if not self.monitoring:
                break
                
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory().used / 1024 / 1024
            
            current_disk = psutil.disk_io_counters()
            disk_read = (current_disk.read_bytes - prev_disk.read_bytes) / 1024 / 1024
            disk_write = (current_disk.write_bytes - prev_disk.write_bytes) / 1024 / 1024
            prev_disk = current_disk
            
            timestamp = datetime.now().strftime('%H:%M:%S')
            print(f'{timestamp},{cpu_percent:.1f},{memory:.1f},{disk_read:.2f},{disk_write:.2f}')
            
        print('‚úÖ Monitoreo completado')
    
    def stop_monitoring(self):
        self.monitoring = False

# Usar: monitor.start_monitoring(30) para 30 segundos
monitor = PerformanceMonitor()
print('Monitor de performance listo. Usar: monitor.start_monitoring(30)')
"
```

---

## üõ†Ô∏è **AUTO-REPARACI√ìN DEL SISTEMA**

### **üîß Script de Auto-Reparaci√≥n**
```powershell
# Crear script de auto-reparaci√≥n completa
@"
#!/usr/bin/env python3
'''
üîß AUTO-REPARACI√ìN DEL SISTEMA ICT ENGINE v6.0
Repara autom√°ticamente los problemas m√°s comunes
'''

import os
import json
import shutil
from pathlib import Path
from datetime import datetime

class SystemAutoRepair:
    def __init__(self):
        self.base_path = Path('.')
        self.repair_log = []
        
    def log_repair(self, action: str, status: str, details: str = ''):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'status': status,
            'details': details
        }
        self.repair_log.append(entry)
        print(f'[{status}] {action}: {details}')
    
    def repair_missing_configs(self):
        '''Crear configuraciones faltantes'''
        config_dir = self.base_path / '01-CORE' / 'config'
        config_dir.mkdir(parents=True, exist_ok=True)
        
        # Config templates
        configs = {
            'log_throttle_config.json': {
                'max_logs_per_second': 10,
                'max_duplicates_per_minute': 5,
                'emergency_threshold': 100,
                'enabled': True
            },
            'risk_management_config.json': {
                'max_positions': 3,
                'max_drawdown_percent': 5.0,
                'emergency_stop_enabled': True,
                'monitoring_enabled': True
            },
            'timestamp_config.json': {
                'format': '%Y-%m-%d %H:%M:%S',
                'timezone': 'UTC',
                'standardized': True
            },
            'log_categorization_rules.json': {
                'application': {'keywords': ['system', 'startup'], 'priority': 1},
                'fvg_memory': {'keywords': ['fvg', 'fair value gap'], 'priority': 5},
                'market_data': {'keywords': ['market', 'price'], 'priority': 4}
            }
        }
        
        for config_name, config_data in configs.items():
            config_file = config_dir / config_name
            if not config_file.exists():
                with open(config_file, 'w') as f:
                    json.dump(config_data, f, indent=2)
                self.log_repair('CREATE_CONFIG', 'SUCCESS', config_name)
            else:
                self.log_repair('CHECK_CONFIG', 'EXISTS', config_name)
    
    def repair_missing_utils(self):
        '''Crear utilidades faltantes'''
        utils_dir = self.base_path / '01-CORE' / 'utils'
        utils_dir.mkdir(parents=True, exist_ok=True)
        
        # Crear deduplicador b√°sico si no existe
        dedup_file = utils_dir / 'realtime_log_deduplicator.py'
        if not dedup_file.exists():
            dedup_code = '''# Realtime Log Deduplicator
import hashlib
from collections import deque
from datetime import datetime, timedelta

class RealtimeLogDeduplicator:
    def __init__(self):
        self.message_history = deque(maxlen=1000)
        self.message_counts = {}
    
    def should_log(self, message: str) -> bool:
        message_hash = hashlib.md5(message.encode()).hexdigest()
        recent_count = self.message_counts.get(message_hash, 0)
        if recent_count >= 5:  # Max 5 duplicates
            return False
        self.message_counts[message_hash] = recent_count + 1
        return True

DEDUPLICATOR = RealtimeLogDeduplicator()
'''
            with open(dedup_file, 'w') as f:
                f.write(dedup_code)
            self.log_repair('CREATE_UTIL', 'SUCCESS', 'realtime_log_deduplicator.py')
    
    def repair_logs_structure(self):
        '''Reparar estructura de logs'''
        logs_dir = self.base_path / '05-LOGS'
        
        # Crear subdirectorios necesarios
        subdirs = ['application', 'fvg_memory', 'market_data', 'patterns', 'dashboard', 'emergency']
        for subdir in subdirs:
            subdir_path = logs_dir / subdir
            subdir_path.mkdir(parents=True, exist_ok=True)
            self.log_repair('CREATE_LOG_DIR', 'SUCCESS', subdir)
    
    def clean_corrupted_logs(self):
        '''Limpiar logs corruptos'''
        logs_dir = self.base_path / '05-LOGS'
        cleaned_count = 0
        
        for log_file in logs_dir.rglob('*.log'):
            try:
                if log_file.stat().st_size > 10 * 1024 * 1024:  # >10MB
                    backup_file = log_file.with_suffix('.log.backup')
                    shutil.move(str(log_file), str(backup_file))
                    cleaned_count += 1
                    self.log_repair('CLEAN_LOG', 'SUCCESS', f'{log_file.name} (>10MB)')
            except Exception as e:
                self.log_repair('CLEAN_LOG', 'ERROR', f'{log_file.name}: {e}')
        
        if cleaned_count > 0:
            self.log_repair('CLEAN_LOGS_TOTAL', 'SUCCESS', f'{cleaned_count} archivos limpiados')
    
    def run_full_repair(self):
        '''Ejecutar reparaci√≥n completa'''
        print('üîß INICIANDO AUTO-REPARACI√ìN DEL SISTEMA')
        print('=' * 50)
        
        self.repair_missing_configs()
        self.repair_missing_utils()
        self.repair_logs_structure()
        self.clean_corrupted_logs()
        
        # Guardar log de reparaciones
        repair_log_file = self.base_path / '03-DOCUMENTATION' / 'reports' / f'auto_repair_{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}.json'
        repair_log_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(repair_log_file, 'w') as f:
            json.dump(self.repair_log, f, indent=2)
        
        print(f'\\n‚úÖ AUTO-REPARACI√ìN COMPLETADA')
        print(f'üìã Log guardado: {repair_log_file}')
        print(f'üîß Acciones realizadas: {len(self.repair_log)}')
        
        # Estad√≠sticas
        success_count = len([r for r in self.repair_log if r['status'] == 'SUCCESS'])
        error_count = len([r for r in self.repair_log if r['status'] == 'ERROR'])
        
        print(f'‚úÖ √âxitos: {success_count}')
        print(f'‚ùå Errores: {error_count}')
        
        return success_count > error_count

if __name__ == '__main__':
    repairer = SystemAutoRepair()
    success = repairer.run_full_repair()
    exit(0 if success else 1)
"@ | Out-File -FilePath "06-TOOLS\system_auto_repair.py" -Encoding UTF8

# Ejecutar auto-reparaci√≥n
python 06-TOOLS\system_auto_repair.py
```

---

## üìã **PROCEDIMIENTOS DE EMERGENCIA**

### **üö® EMERGENCY STOP - Detener Sistema Inmediatamente**
```powershell
# 1. Parar todos los procesos
Get-Process python | Where-Object {$_.MainWindowTitle -like "*ICT*"} | Stop-Process -Force

# 2. Limpiar estado de emergencia
python -c "
import json
emergency_file = '04-DATA/emergency/system_state_emergency.json'
try:
    with open(emergency_file, 'w') as f:
        json.dump({
            'status': 'MANUAL_STOP',
            'timestamp': '$(Get-Date -Format "yyyy-MM-ddTHH:mm:ss")',
            'reason': 'Manual emergency stop'
        }, f, indent=2)
    print('‚úÖ Emergency state saved')
except:
    print('‚ö†Ô∏è Could not save emergency state')
"

# 3. Verificar que todo est√© detenido
Get-Process python | Where-Object {$_.MainWindowTitle -like "*ICT*"}
```

### **üîÑ RESTART COMPLETO DEL SISTEMA**
```powershell
# 1. Emergency stop
# (ejecutar procedimiento anterior)

# 2. Auto-reparaci√≥n
python 06-TOOLS\system_auto_repair.py

# 3. Validaci√≥n completa
python 06-TOOLS\validation_quick_test.py

# 4. Restart seguro
if ($LASTEXITCODE -eq 0) {
    Write-Host "‚úÖ Sistema validado, reiniciando..." -ForegroundColor Green
    python main.py
} else {
    Write-Host "‚ùå Sistema NO validado, revisar errores" -ForegroundColor Red
}
```

---

## ‚úÖ **VERIFICACI√ìN POST-RESOLUCI√ìN**

### **üìä Checklist de Validaci√≥n Final**
```powershell
Write-Host "üìã CHECKLIST DE VALIDACI√ìN FINAL" -ForegroundColor Yellow
Write-Host "=" * 40

# 1. Validaci√≥n autom√°tica
Write-Host "1Ô∏è‚É£ Ejecutando validaci√≥n autom√°tica..." -ForegroundColor Green
python 06-TOOLS\validation_quick_test.py
$validation_result = $LASTEXITCODE

# 2. Verificar logs
Write-Host "2Ô∏è‚É£ Verificando logs..." -ForegroundColor Green
$log_count = (Get-ChildItem "05-LOGS\application\*.log" | Measure-Object).Count
if ($log_count -gt 0) {
    Write-Host "   ‚úÖ Logs siendo generados" -ForegroundColor Green
} else {
    Write-Host "   ‚ùå No se est√°n generando logs" -ForegroundColor Red
}

# 3. Verificar configuraciones
Write-Host "3Ô∏è‚É£ Verificando configuraciones..." -ForegroundColor Green
$config_count = (Get-ChildItem "01-CORE\config\*.json" | Measure-Object).Count
Write-Host "   üìÅ Configuraciones encontradas: $config_count"

# 4. Test de funcionalidad b√°sica
Write-Host "4Ô∏è‚É£ Test de funcionalidad b√°sica..." -ForegroundColor Green
python -c "
try:
    from core.smart_trading_logger import SmartTradingLogger
    logger = SmartTradingLogger('test')
    logger.info('Test post-reparaci√≥n')
    print('   ‚úÖ Logger funcionando')
except Exception as e:
    print(f'   ‚ùå Error en logger: {e}')
"

# Resultado final
if ($validation_result -eq 0) {
    Write-Host "`nüéâ SISTEMA COMPLETAMENTE REPARADO Y FUNCIONAL" -ForegroundColor Green
    Write-Host "‚úÖ Listo para operaci√≥n normal" -ForegroundColor Green
} else {
    Write-Host "`n‚ö†Ô∏è SISTEMA REQUIERE ATENCI√ìN ADICIONAL" -ForegroundColor Yellow
    Write-Host "üìû Considerar soporte t√©cnico especializado" -ForegroundColor Yellow
}
```

---

## üìû **ESCALACI√ìN Y SOPORTE**

### **üî¥ Cu√°ndo Escalar a Soporte T√©cnico:**
- ‚ùå Score de validaci√≥n persistentemente < 60%
- üö® Errores cr√≠ticos que no se resuelven con auto-reparaci√≥n
- üíæ Corrupci√≥n de datos o p√©rdida de configuraciones
- ‚ö° Performance degradada >50% sin causa aparente
- üîÑ Sistema entra en loop de errores

### **üìã Informaci√≥n a Recopilar para Soporte:**
```powershell
# Crear paquete de diagn√≥stico para soporte
@"
# PAQUETE DE DIAGN√ìSTICO - ICT ENGINE v6.0
# Generado: $(Get-Date)

## INFORMACI√ìN DEL SISTEMA
$(python --version)
$(Get-ComputerInfo | Select-Object WindowsProductName, TotalPhysicalMemory)

## VALIDACI√ìN ACTUAL
"@ | Out-File -FilePath "diagnostico_soporte.txt"

python 06-TOOLS\validation_quick_test.py >> diagnostico_soporte.txt 2>&1

Write-Host "üìã Paquete de diagn√≥stico creado: diagnostico_soporte.txt"
Write-Host "üìß Adjuntar este archivo al solicitar soporte t√©cnico"
```

---

**üéØ OBJETIVO FINAL:** Resolver cualquier problema en <30 minutos usando procedimientos estructurados y herramientas automatizadas.

**‚úÖ CRITERIO DE √âXITO:** Sistema funcionando con score de validaci√≥n >= 80% y sin errores cr√≠ticos.
