# üèóÔ∏è TEMPLATES DE IMPLEMENTACI√ìN ENTERPRISE

**Archivo:** `03-templates-implementacion.md`  
**Prop√≥sito:** Templates de c√≥digo enterprise listo para copy-paste

---

## üéØ **TEMPLATE PRINCIPAL ENTERPRISE v6.0**

### **üìã CABECERA EST√ÅNDAR ENTERPRISE**
```python
#!/usr/bin/env python3
"""
[T√çTULO DEL M√ìDULO] - ICT ENGINE v6.0 ENTERPRISE
================================================

[DESCRIPCI√ìN ESPEC√çFICA DEL PROP√ìSITO]

‚úÖ ARQUITECTURA ENTERPRISE:
- SIC v3.1: [‚úÖ/‚ùå] [Justificaci√≥n si es ‚ùå]
- SLUC v2.1: [‚úÖ/‚ùå] [Uso espec√≠fico del logging]
- Memoria Trader: [‚úÖ/‚ùå] [Tipo de memoria requerida]
- Performance <5s: [‚úÖ/‚ùå] [Optimizaciones implementadas]
- MT5 Integration: [‚úÖ/‚ùå] [Tipo de datos utilizados]

üéØ FUNCIONALIDAD:
[Descripci√≥n espec√≠fica de qu√© hace este m√≥dulo]

üìä M√âTRICAS:
- Tiempo respuesta objetivo: [X]s
- Memoria m√°xima: [X]MB
- Precisi√≥n objetivo: [X]%

Autor: ICT Engine Enterprise Team
Fecha: [FECHA ACTUAL]
Versi√≥n: v6.0.X-enterprise-[estado]
"""

# üìã IMPORTS ENTERPRISE EST√ÅNDAR
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import sys
import os
import time
import logging

# üèóÔ∏è SIC/SLUC ENTERPRISE (OBLIGATORIO si aplica)
try:
    from sistema.sic_bridge import SICBridge
    from core.smart_trading_logger import SmartTradingLogger
    ENTERPRISE_READY = True
except ImportError as e:
    print(f"‚ö†Ô∏è ENTERPRISE COMPONENTS NOT AVAILABLE: {e}")
    ENTERPRISE_READY = False

# üìä DATA SCIENCE IMPORTS (si aplica)
try:
    import pandas as pd
    import numpy as np
    ANALYTICS_READY = True
except ImportError:
    ANALYTICS_READY = False

# üß† MEMORIA IMPORTS (si aplica)
try:
    from core.data_management.unified_memory_system import UnifiedMemorySystem
    MEMORY_READY = True
except ImportError:
    MEMORY_READY = False

# [RESTO DE IMPORTS ESPEC√çFICOS DEL M√ìDULO]
```

---

## üèõÔ∏è **TEMPLATE CLASE ENTERPRISE PRINCIPAL**

```python
@dataclass
class [NombreClase]Config:
    """Configuraci√≥n enterprise para [NombreClase]"""
    # Performance settings
    max_execution_time: float = 5.0  # segundos
    memory_limit_mb: int = 100
    enable_caching: bool = True
    
    # Logging settings
    log_level: str = "INFO"
    enable_performance_logging: bool = True
    enable_memory_logging: bool = True
    
    # Integration settings
    use_sic_bridge: bool = True
    use_memory_system: bool = True
    enable_fallback: bool = True

class [NombreClase]:
    """
    [DOCUMENTACI√ìN ESPEC√çFICA DE LA CLASE]
    
    ‚úÖ ENTERPRISE FEATURES:
    - [Lista espec√≠fica de caracter√≠sticas enterprise]
    - [Integraci√≥n SIC/SLUC con detalles]
    - [Performance optimizations implementadas]
    - [Memory management strategy]
    
    üìä USAGE:
    ```python
    analyzer = [NombreClase](config=[NombreClase]Config())
    result = analyzer.metodo_principal(datos)
    ```
    """
    
    def __init__(self, config: Optional[[NombreClase]Config] = None):
        """
        Inicializaci√≥n enterprise con configuraci√≥n robusta
        
        Args:
            config: Configuraci√≥n enterprise opcional
        """
        # ‚úÖ CONFIGURACI√ìN
        self.config = config or [NombreClase]Config()
        
        # ‚úÖ OBLIGATORIO: Logger SLUC enterprise
        self.logger = SmartTradingLogger() if ENTERPRISE_READY else logging.getLogger(__name__)
        
        # ‚úÖ OBLIGATORIO: SIC Bridge si disponible y configurado
        self.sic = None
        if ENTERPRISE_READY and self.config.use_sic_bridge:
            try:
                self.sic = SICBridge()
                self.logger.info("üèóÔ∏è SIC Bridge inicializado exitosamente", 
                               component="[COMPONENTE]")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è SIC Bridge no disponible: {e}", 
                                  component="[COMPONENTE]")
        
        # üß† MEMORIA SYSTEM (si aplica)
        self.memory = None
        if MEMORY_READY and self.config.use_memory_system:
            try:
                self.memory = UnifiedMemorySystem()
                self.logger.info("üß† Sistema de memoria inicializado", 
                               component="[COMPONENTE]")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Sistema de memoria no disponible: {e}",
                                  component="[COMPONENTE]")
        
        # üìä M√âTRICAS PERFORMANCE
        self.metrics = {
            'total_executions': 0,
            'successful_executions': 0,
            'average_execution_time': 0.0,
            'peak_memory_usage': 0,
            'error_count': 0
        }
        
        # ‚ö° CACHE (si habilitado)
        self.cache = {} if self.config.enable_caching else None
        
        # üöÄ LOG INICIALIZACI√ìN COMPLETA
        self.logger.info(f"‚úÖ {self.__class__.__name__} inicializado correctamente",
                        component="[COMPONENTE]",
                        extra={
                            'enterprise_ready': ENTERPRISE_READY,
                            'memory_ready': MEMORY_READY,
                            'config': self.config.__dict__
                        })
    
    def metodo_principal(self, datos: Any, **kwargs) -> Dict[str, Any]:
        """
        M√©todo principal enterprise con logging y m√©tricas completas
        
        Args:
            datos: [Descripci√≥n espec√≠fica del tipo de datos]
            **kwargs: Par√°metros adicionales
            
        Returns:
            Dict con resultado estructurado enterprise
            
        Raises:
            ValueError: Si datos no son v√°lidos
            RuntimeError: Si excede tiempo l√≠mite o memoria
        """
        # ‚è±Ô∏è INICIO TIMING PERFORMANCE
        start_time = time.time()
        self.metrics['total_executions'] += 1
        
        # ‚úÖ OBLIGATORIO: Log inicio con contexto completo
        self.logger.info("üöÄ Iniciando [operaci√≥n espec√≠fica]", 
                        component="[COMPONENTE]",
                        extra={
                            'input_type': type(datos).__name__,
                            'input_size': len(datos) if hasattr(datos, '__len__') else 'N/A',
                            'kwargs': kwargs,
                            'execution_id': self.metrics['total_executions']
                        })
        
        try:
            # üîç VALIDACI√ìN DE ENTRADA
            self._validar_entrada(datos)
            
            # üíæ CHECK CACHE (si habilitado)
            cache_key = self._generar_cache_key(datos, kwargs)
            if self.cache and cache_key in self.cache:
                self.logger.debug("üì¶ Resultado obtenido desde cache",
                                component="[COMPONENTE]",
                                extra={'cache_key': cache_key})
                return self.cache[cache_key]
            
            # üß† MEMORIA CONTEXT (si disponible)
            memory_context = None
            if self.memory:
                memory_context = self.memory.get_context('[CONTEXTO_ESPEC√çFICO]')
            
            # üèóÔ∏è L√ìGICA PRINCIPAL
            resultado = self._procesar_logica_principal(datos, memory_context, **kwargs)
            
            # üíæ GUARDAR EN CACHE (si habilitado)
            if self.cache and cache_key:
                self.cache[cache_key] = resultado
            
            # üß† ACTUALIZAR MEMORIA (si disponible)
            if self.memory and resultado.get('success', False):
                self.memory.store_pattern('[PATTERN_TYPE]', resultado)
            
            # ‚è±Ô∏è CALCULAR M√âTRICAS
            execution_time = time.time() - start_time
            self.metrics['successful_executions'] += 1
            self._actualizar_metricas_performance(execution_time)
            
            # ‚ö†Ô∏è VERIFICAR PERFORMANCE L√çMITE
            if execution_time > self.config.max_execution_time:
                self.logger.warning(f"‚ö†Ô∏è Performance limit exceeded: {execution_time:.3f}s > {self.config.max_execution_time}s",
                                  component="[COMPONENTE]")
            
            # ‚úÖ OBLIGATORIO: Log √©xito con m√©tricas detalladas
            self.logger.info("‚úÖ [Operaci√≥n espec√≠fica] completada exitosamente",
                           component="[COMPONENTE]",
                           extra={
                               'execution_time': execution_time,
                               'result_summary': self._crear_resumen_resultado(resultado),
                               'performance_within_limits': execution_time <= self.config.max_execution_time,
                               'cache_used': cache_key in self.cache if self.cache else False,
                               'memory_updated': memory_context is not None
                           })
            
            return resultado
            
        except Exception as e:
            # ‚è±Ô∏è TIEMPO DE ERROR
            execution_time = time.time() - start_time
            self.metrics['error_count'] += 1
            
            # ‚úÖ OBLIGATORIO: Log error con contexto completo
            self.logger.error(f"‚ùå Error en [operaci√≥n espec√≠fica]: {str(e)}",
                             component="[COMPONENTE]",
                             extra={
                                 'error_type': type(e).__name__,
                                 'error_details': str(e),
                                 'execution_time_before_error': execution_time,
                                 'input_data_summary': self._crear_resumen_entrada(datos),
                                 'kwargs': kwargs,
                                 'stack_trace': True  # Para logging detallado
                             })
            
            # üîÑ FALLBACK (si configurado)
            if self.config.enable_fallback:
                return self._ejecutar_fallback(datos, e)
            
            raise
    
    def _validar_entrada(self, datos: Any) -> None:
        """Validaci√≥n robusta de datos de entrada"""
        if datos is None:
            raise ValueError("Datos de entrada no pueden ser None")
        
        # [VALIDACIONES ESPEC√çFICAS DEL M√ìDULO]
        
    def _procesar_logica_principal(self, datos: Any, memory_context: Optional[Dict], **kwargs) -> Dict[str, Any]:
        """
        L√≥gica principal del procesamiento
        
        [IMPLEMENTACI√ìN ESPEC√çFICA AQU√ç]
        """
        # PLACEHOLDER - IMPLEMENTAR L√ìGICA ESPEC√çFICA
        resultado = {
            'success': True,
            'data': datos,  # PLACEHOLDER
            'timestamp': datetime.now().isoformat(),
            'execution_context': {
                'memory_available': memory_context is not None,
                'kwargs': kwargs
            }
        }
        
        return resultado
    
    def _generar_cache_key(self, datos: Any, kwargs: Dict) -> Optional[str]:
        """Genera clave de cache √∫nica para los datos"""
        if not self.config.enable_caching:
            return None
        
        # IMPLEMENTAR L√ìGICA DE CACHE KEY ESPEC√çFICA
        return f"[MODULO]_{hash(str(datos))}_{hash(str(sorted(kwargs.items())))}"
    
    def _crear_resumen_resultado(self, resultado: Dict) -> Dict:
        """Crea resumen del resultado para logging"""
        return {
            'success': resultado.get('success', False),
            'data_size': len(resultado.get('data', [])) if hasattr(resultado.get('data'), '__len__') else 'N/A',
            'timestamp': resultado.get('timestamp')
        }
    
    def _crear_resumen_entrada(self, datos: Any) -> Dict:
        """Crea resumen de datos de entrada para logging"""
        return {
            'type': type(datos).__name__,
            'size': len(datos) if hasattr(datos, '__len__') else 'N/A',
            'sample': str(datos)[:100] if hasattr(datos, '__str__') else 'N/A'
        }
    
    def _actualizar_metricas_performance(self, execution_time: float) -> None:
        """Actualiza m√©tricas de performance"""
        # Media m√≥vil simple de tiempo de ejecuci√≥n
        if self.metrics['successful_executions'] == 1:
            self.metrics['average_execution_time'] = execution_time
        else:
            total_time = self.metrics['average_execution_time'] * (self.metrics['successful_executions'] - 1)
            self.metrics['average_execution_time'] = (total_time + execution_time) / self.metrics['successful_executions']
    
    def _ejecutar_fallback(self, datos: Any, error: Exception) -> Dict[str, Any]:
        """Ejecuta l√≥gica de fallback en caso de error"""
        self.logger.info("üîÑ Ejecutando fallback por error", 
                        component="[COMPONENTE]",
                        extra={'original_error': str(error)})
        
        return {
            'success': False,
            'fallback': True,
            'error': str(error),
            'timestamp': datetime.now().isoformat()
        }
    
    def get_metrics(self) -> Dict[str, Any]:
        """Obtiene m√©tricas de performance del componente"""
        return {
            **self.metrics,
            'success_rate': (self.metrics['successful_executions'] / self.metrics['total_executions'] * 100) 
                           if self.metrics['total_executions'] > 0 else 0,
            'component': "[COMPONENTE]",
            'enterprise_ready': ENTERPRISE_READY,
            'memory_ready': MEMORY_READY
        }
    
    def health_check(self) -> Dict[str, Any]:
        """Verifica salud del componente"""
        health = {
            'status': 'healthy',
            'checks': {
                'sic_bridge': self.sic is not None,
                'memory_system': self.memory is not None,
                'logger': self.logger is not None,
                'cache': self.cache is not None if self.config.enable_caching else True
            },
            'metrics': self.get_metrics(),
            'timestamp': datetime.now().isoformat()
        }
        
        # Determinar estado general
        if not all(health['checks'].values()):
            health['status'] = 'degraded'
        
        if self.metrics['error_count'] > 0 and self.metrics['total_executions'] > 0:
            error_rate = self.metrics['error_count'] / self.metrics['total_executions']
            if error_rate > 0.1:  # >10% error rate
                health['status'] = 'unhealthy'
        
        return health
```

---

## ‚ö° **TEMPLATE FUNCI√ìN SIMPLE ENTERPRISE**

```python
def funcion_enterprise(parametros: TipoParametros, 
                      logger: Optional[SmartTradingLogger] = None) -> Dict[str, Any]:
    """
    Funci√≥n enterprise con logging y error handling robusto
    
    Args:
        parametros: [Descripci√≥n espec√≠fica]
        logger: Logger opcional (se crea uno si no se proporciona)
    
    Returns:
        Dict con resultado estructurado
    """
    # Setup logger
    if logger is None:
        logger = SmartTradingLogger() if ENTERPRISE_READY else logging.getLogger(__name__)
    
    start_time = time.time()
    
    # Log inicio
    logger.info("üöÄ Iniciando [funci√≥n espec√≠fica]",
                component="[COMPONENTE]", 
                extra={'params': parametros})
    
    try:
        # Validaci√≥n
        if not parametros:
            raise ValueError("Par√°metros requeridos")
        
        # L√≥gica principal
        resultado = {
            'success': True,
            'data': parametros,  # PLACEHOLDER
            'execution_time': 0.0,
            'timestamp': datetime.now().isoformat()
        }
        
        # Calcular tiempo
        execution_time = time.time() - start_time
        resultado['execution_time'] = execution_time
        
        # Log √©xito
        logger.info("‚úÖ [Funci√≥n espec√≠fica] completada",
                   component="[COMPONENTE]",
                   extra={'execution_time': execution_time,
                          'result_summary': resultado})
        
        return resultado
        
    except Exception as e:
        execution_time = time.time() - start_time
        
        # Log error
        logger.error(f"‚ùå Error en [funci√≥n espec√≠fica]: {e}",
                    component="[COMPONENTE]",
                    extra={'error_type': type(e).__name__,
                           'execution_time': execution_time,
                           'params': parametros})
        
        # Retornar error estructurado
        return {
            'success': False,
            'error': str(e),
            'error_type': type(e).__name__,
            'execution_time': execution_time,
            'timestamp': datetime.now().isoformat()
        }
```

---

## üéØ **CHECKLIST DE IMPLEMENTACI√ìN**

### **‚úÖ Antes de usar templates:**
```markdown
üìã VERIFICACI√ìN OBLIGATORIA:
‚îú‚îÄ‚îÄ ‚úÖ Reemplazar [TODOS_LOS_PLACEHOLDERS] con valores espec√≠ficos
‚îú‚îÄ‚îÄ ‚úÖ Adaptar imports seg√∫n necesidades del m√≥dulo
‚îú‚îÄ‚îÄ ‚úÖ Definir validaciones espec√≠ficas en _validar_entrada()
‚îú‚îÄ‚îÄ ‚úÖ Implementar l√≥gica real en _procesar_logica_principal()
‚îú‚îÄ‚îÄ ‚úÖ Configurar logging component name consistente
‚îú‚îÄ‚îÄ ‚úÖ Ajustar performance limits seg√∫n requisitos
‚îú‚îÄ‚îÄ ‚úÖ Definir cache strategy si aplica
‚îî‚îÄ‚îÄ ‚úÖ Implementar health checks espec√≠ficos
```

### **üèóÔ∏è Customizaci√≥n por tipo de m√≥dulo:**
- **Detector/Analyzer:** Agregar precision/recall metrics
- **Data Manager:** Agregar data validation y cleanup
- **Trading Component:** Agregar risk management y position sizing
- **Memory Component:** Agregar compression y TTL management
- **Integration Component:** Agregar connection pooling y retry logic

---

**üìã ESTADO:** ‚úÖ **TEMPLATES ENTERPRISE LISTOS PARA USO**  
**üéØ OBJETIVO:** Copy-paste con customizaci√≥n m√≠nima para calidad enterprise  
**‚ö° USO:** Copiar template completo y adaptar placeholders a necesidades espec√≠ficas
